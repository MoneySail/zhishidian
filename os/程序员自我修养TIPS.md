程序员的自我修养TIPS
====================

多核处理器的基本想法
--------------------
　　多个处理器共享比较昂贵的缓存部件，保留多个核心，并且以一个处理器的外包装进行出售  

基本的层级结构
--------------
　　底层硬件 => 操作系统内核 => 运行时库(Run Time Library) =>应用程序+开发工具

再来一遍线程吧
--------------
　　线程：又称作轻量级进程(LWP), 是程序执行流的最小单元，一个标准的线程由线程ID，当前指令指针(PC),  
寄存器集合和堆栈组成。通常意义上，一个进程由一个到多个线程组成，多个线程之间共享程序的内存空间  
(包括代码段，数据段，堆等)，以及一些进程级的资源(如打开文件和信号)。  
　　线程私有的存储空间包括：  
　　栈：(尽管并非完全无法被其它线程访问，但一般情况下任然可以认为是私有的数据)  
　　线程局部存储(TLS => Thread Local Storage):线程局部存储是某些操作系统为线程单独设立的存储空间，通常提供有限的容量  
　　寄存器：寄存器是执行流的基本数据，因此为线程私有。  

# 线程的并发 #
　　单处理器对应多线程的情况下，并发是一种模拟出来的状态。操作系统会让多线程程序轮流执行，每次执行一小段时间  
(通常是几十到几百毫秒)，这样每个线程看起来就像在同时执行。这样在一个处理器上切换不同的行为称之为线程调度  
(Thread Schedule).在线程调度中，线程通常至少拥有三种状态，分别为：
　　运行(Running) => 此线程正在运行  
　　就绪(Ready) => 此时线程可以立刻运行，但CPU已经被占用  
　　等待(Waiting) => 此时线程正在等待某一事件(通常是I/O或者同步)发生，无法执行  

　　处于运行中的线程可以拥有一段执行的时间，这段时间成为"时间片(Time Slice)"，当时间片用尽的时候，该进程进入  
就绪状态。如果在时间片运行之前就等待某事件，那么它将进入等待状态。每当一个线程离开运行状态时候，调度系统就会  
选择一个其他的就绪状态的线程进行运行。

　　饿死现象:在优先级调度情况下，一个线程被饿死，是说它的优先级过低，始终无法得到执行  
为避免这种现象，调度系统会逐步提升那些等待了过长时间得不到执行的线程的优先级。

　　用户优先级改变的三种方式：  
　　1、用户指定优先级  
　　2、根据进入等待状态的频繁程度提升或者降低优先级  
　　3、长时间得不到执行而被提升优先级  

　　可抢占线程和不可抢占线程：  
　　
　　Linux对于多线程的支持颇为贫乏，linux内核中并不存在真正意义上的线程概念，  
Linux将所有的执行实体(无论是线程还是进程)都成为任务，每一个任务的概念上都类似  
于一个单线程的进程，具有内存空间，执行实体，文件资源等。不过Linux下不同任务之间  
可以选择共享内存空间，因而在实际意义上，共享一个内存空间的多个任务构成了一个  
进程，这个任务也成了这个进程里面的线程

# 写时复制 #
　　所谓的写时复制，指的是两个任务可以同时自由地读取内存，但任意一个任务试图  
对内存进行修改时，内存就会复制一份提供给修改方单独使用，以免影响到其他任务的  
使用。

# 原子指令 #
　　一条程序语句(如i++)等的一些内容，会被CPU解释为好几条指令，当多个线程共享  
这个i的时候，读取的结果不一定是正确的。  

# 编译器问题 #
　　编译器可能在编译代码时候，为了优化交换两条指令。volatile可以避免这种操作  
但是CPU动态调度换序, 是无法避免的(即是CPU把指令执行的顺序动态交换执行.)  

编译和链接
----------

# 预编译 #
　　预编译过程主要处理那些源代码文件中以"#"开始的预编译指令，如"include", "#define"等，主要的处理规则如下所示  
　　1.将所有的"#define"删除，并且展开所有的宏定义。
　　2.处理所有的条件预编译指令，如"#if", "#ifdef", "#elif", "#else", "#endif"
　　3.处理"#include"预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，  
　　也就是说被包含的文件可能还包含其他文件。  
　　4.删除所有的注释"//"和"/* */"
　　5.添加行号和文件名标识，比如#2 "hello.c" 2, 以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误  
　　或警告时能够显示行号。  
　　6.保留所有的#pragma编译器指令，因为编译器须要使用它们。  
　　经过预编译的.i文件不包含任何宏定义，因为所有的宏已经展开，并且包含的文件也已经被插入到.i文件中。

# 编译 #
　　编译过程就是把预处理完的文件经过一系列的词法分析，语法分析，语义分析及优化后产生相应的汇编代码文件.  

# 汇编 #
　　汇编器是将汇编代码转换成机器代码可以执行的指令，每一个汇编的语句几乎都对应一条机器指令。

# 链接 #
　　链接的主要作用就是把各个模块之间的引用的部分都处理好，使得各个模块之间能够正确地链接，  
链接的过程主要包括了地址和空间的分配(Address and Storage Allocation), 符号决议(Symbol Resolution)  
, 重定位(Relocation)这些步骤。

编译器做了什么
--------------

目标文件
--------
　　一般C语言编译后执行语句都编译成机器代码，保存在.text段;已初始化的全局变量和局部静态变量都在.data  
段，未初始化的全局变量和局部静态变量一般放在一个.bss的段里面。.bss段只是为为初始化的全局变量和局部静态  
变量预留位置而已，它并没有内容, 所以它在文件中也不占据空间。

符号修饰和符号命名
------------------

# 函数签名(C++) #
　　函数签名包含了一个函数的信息，包括函数名，它的参数类型，它所在的类和名称空间，及其它信息。函数签名  
用于识别不同的函数，

# .init 和 .fini 段 #
　　ELF文件中还有两种特殊的段，
　　.init段 => 该段里面保存的是可执行指令，它构成了进程的初始化代码。因此，在一个程序开始运行时，在main  
函数被调用之前，GLibc的初始化部分安排执行这个段中的代码。(全局对象的构造)  
　　.fini段 => 该段保存着进程终止代码指令。因此，但一个程序的main函数正常退出时候，GLibc会执行这个段中的代码  
（全局对象的析构）  

# ABI #
　　Application Binary Interface

可执行文件的装载和进程
----------------------

# 延迟绑定 #
　　当函数第一次被用到时才进行绑定  

                  
                   
