Effective_C++
=============

Introduction
------------
　　记录本书需要学习和掌握的知识点  

Begin
-----


-------------------------------------------------------------------------------

　　1.对于单纯常量，最好以const对象或enums替换#defines  
　　2.对于形似函数的宏(marcos), 最好用inline函数替换#defines  

-------------------------------------------------------------------------------

　　3.将某些东西声明为const,可以帮助编译器侦测出错误用法.const可以施加于任何作用域的对象，函数参数，函数返回类型，成员函数本体。  
　　4.当const和 non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可以避免代码重复。  

-------------------------------------------------------------------------------

　　5.为内置对象进行手工初始化，因为C++不保证初始化他们。  
    6.构造函数最好使用成员初值列表(member initilalization list), 而不要在构造函数本体内使用赋值操作，初值列出的成员变量，其排列次序  
　　　应该和它们在class中的声明次序相同。  
　　7.为避免"跨编译单元之初始化次序"问题，请以local static对象替换non-local static对象。  

-------------------------------------------------------------------------------

　　8.编译器可以暗自为class创建default构造函数, copy构造函数，copy assianment操作符，以及析构函数  

-------------------------------------------------------------------------------
　　
　　9.polymophic(带多态性质的)base classes 应该声明一个virtual析构函数。如果class带有任何virtual函数，  
　　　它就应该拥有一个virtual析构函数  
　　10.Classes的设计目的如果不是作为base classes使用，或不是为了具备多态性(polymorphically), 就不应该声明virtual析构函数  

-------------------------------------------------------------------------------

　　11.析构函数绝对不要抛出异常, 如果一个析构函数调用的函数可能抛出异常，析构函数应该能够捕捉任何异常，然后吞下它们(不传播)  
　　　或者结束程序。  
　　12.如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数(而非在析构函数内)执行该操作。  
　　13.在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class（比起当前执行的构造函数和析构函数那层）  
　　14.确定任何函数如果操作一个以上的对象的，而其中多个对象是同一个对象时，其行为仍然正确。  
　　

-------------------------------------------------------------------------------

　　15.Copying函数应该确保复制"对象内的所有成员变量"及"所有的base class成分"  
　　16.不要尝试以某个copying函数实现另外一个copying函数，应该将其共同机能放进第三个函数中，并由两个copying函数共同调用  

-------------------------------------------------------------------------------

　　17.为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。  
　　18.两个常被使用的RAII classes分别是 tr1:shared_ptr和auto_ptr, 前者通常是最佳选择  
　　19.复制RAII class copying行为是：抑制copying, 施行引用计数法(reference counting).  

-------------------------------------------------------------------------------

　　20.设计class犹如设计type
     => 新type的对象应该如何创建与销毁   
     => 对象的初始化和对象的赋值应该有什么区别  
     => 新type的对象如果被passed by value （以值传递, 意味着什么？  
     => 什么是新type的"合法值"？  
     => 你的新type需要配合某个继承图系吗  
     => 你的新type需要什么样的转换？  
     => 什么样的操作符和函数对此新type而言是合理的  
     => 什么样的标准函数应该驳回？  
     => 谁该采用新type的成员？  
     => 什么是新type的"未声明接口"(undeclared interface)?他对效率，异常安全性 及资源运用方面提供何种保证？  
     => 你的新type有多么一般化？  

-------------------------------------------------------------------------------

　　21.尽量以pass-by-reference-to-const替换pass-by-value。
    22.规则21并不适用于内置类型，以及STL的迭代器和函数对象，对它们而言，pass-by-value往往比较适当。  
    
-------------------------------------------------------------------------------

　　23.绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象  
　　或返回pointer或reference指向一个local static对象而有可能需要多个这样的对象  

-------------------------------------------------------------------------------

　　24.切记将成员变量声明为private, 这可赋予客户访问数据的一致性  
    25.protected并不比public更具有封装性  
